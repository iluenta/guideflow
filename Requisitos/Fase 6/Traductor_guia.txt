21:29Sistema de Multilenguaje para la Gu√≠a
Excelente observaci√≥n. Vamos a implementar un sistema completo de traducci√≥n autom√°tica con IA.

ESTRATEGIA: TRADUCCI√ìN BAJO DEMANDA CON CACH√â
Principio:

‚ùå NO traducir todo por adelantado (costoso, inflexible)
‚úÖ Traducir solo lo que el hu√©sped necesita, cuando lo necesita
‚úÖ Cachear traducciones para reutilizar
‚úÖ Detectar idioma del navegador autom√°ticamente


ARQUITECTURA DE DATOS
Schema de Base de Datos
sql-- Tabla de idiomas soportados
CREATE TABLE supported_languages (
  code VARCHAR(5) PRIMARY KEY, -- 'es', 'en', 'fr', 'de', 'it', 'pt', 'zh', 'ja'
  name VARCHAR(50) NOT NULL, -- 'Espa√±ol', 'English', 'Fran√ßais'
  native_name VARCHAR(50) NOT NULL, -- 'Espa√±ol', 'English', 'Fran√ßais'
  flag_emoji VARCHAR(10), -- 'üá™üá∏', 'üá¨üáß', 'üá´üá∑'
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Datos iniciales
INSERT INTO supported_languages (code, name, native_name, flag_emoji) VALUES
  ('es', 'Spanish', 'Espa√±ol', 'üá™üá∏'),
  ('en', 'English', 'English', 'üá¨üáß'),
  ('fr', 'French', 'Fran√ßais', 'üá´üá∑'),
  ('de', 'German', 'Deutsch', 'üá©üá™'),
  ('it', 'Italian', 'Italiano', 'üáÆüáπ'),
  ('pt', 'Portuguese', 'Portugu√™s', 'üáµüáπ'),
  ('ca', 'Catalan', 'Catal√†', 'üè¥'),
  ('nl', 'Dutch', 'Nederlands', 'üá≥üá±'),
  ('zh', 'Chinese', '‰∏≠Êñá', 'üá®üá≥'),
  ('ja', 'Japanese', 'Êó•Êú¨Ë™û', 'üáØüáµ'),
  ('ko', 'Korean', 'ÌïúÍµ≠Ïñ¥', 'üá∞üá∑'),
  ('ru', 'Russian', '–†—É—Å—Å–∫–∏–π', 'üá∑üá∫');

-- Tabla de preferencias de idioma por hu√©sped
CREATE TABLE guest_language_preferences (
  access_token VARCHAR(32) REFERENCES guest_access_tokens(access_token),
  language_code VARCHAR(5) REFERENCES supported_languages(code),
  detected_language VARCHAR(5), -- Idioma detectado del navegador
  manually_selected BOOLEAN DEFAULT false, -- ¬øLo eligi√≥ manualmente?
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  PRIMARY KEY (access_token)
);

-- Cach√© de traducciones
CREATE TABLE translation_cache (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  
  -- Qu√© se traduce
  source_type VARCHAR(50) NOT NULL, -- 'property_context', 'restaurant', 'activity', 'chat_message', 'ui_label'
  source_id VARCHAR(255) NOT NULL, -- ID del contenido original
  source_field VARCHAR(100), -- Campo espec√≠fico (ej: 'description', 'name')
  
  -- Idiomas
  source_language VARCHAR(5) DEFAULT 'es',
  target_language VARCHAR(5) NOT NULL,
  
  -- Contenido
  source_text TEXT NOT NULL,
  translated_text TEXT NOT NULL,
  
  -- Metadatos
  translation_method VARCHAR(20) DEFAULT 'claude', -- 'claude', 'cached', 'manual'
  tokens_used INTEGER,
  cost_usd DECIMAL(10, 6),
  quality_score DECIMAL(3, 2), -- 0-1 (opcional, para feedback)
  
  -- Cach√©
  cache_hits INTEGER DEFAULT 0,
  last_used_at TIMESTAMP DEFAULT NOW(),
  created_at TIMESTAMP DEFAULT NOW(),
  
  -- √çndices para b√∫squeda r√°pida
  UNIQUE INDEX idx_translation_lookup (source_type, source_id, source_field, target_language),
  INDEX idx_cache_hits (cache_hits, last_used_at)
);

-- Vista para analytics de traducciones
CREATE VIEW translation_stats AS
SELECT 
  target_language,
  source_type,
  COUNT(*) as total_translations,
  SUM(cache_hits) as total_cache_hits,
  SUM(cost_usd) as total_cost,
  AVG(quality_score) as avg_quality
FROM translation_cache
GROUP BY target_language, source_type;

COMPONENTE DE SELECTOR DE IDIOMA
LanguageSelector.tsx
typescript// components/LanguageSelector.tsx
'use client';

import { useState, useEffect } from 'react';
import { Globe } from 'lucide-react';

interface Language {
  code: string;
  name: string;
  nativeName: string;
  flagEmoji: string;
}

export default function LanguageSelector({ 
  accessToken,
  onLanguageChange 
}: { 
  accessToken: string;
  onLanguageChange?: (lang: string) => void;
}) {
  const [languages, setLanguages] = useState<Language[]>([]);
  const [currentLang, setCurrentLang] = useState<string>('es');
  const [isOpen, setIsOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    loadLanguages();
    loadUserPreference();
  }, []);

  const loadLanguages = async () => {
    const response = await fetch('/api/languages');
    const data = await response.json();
    setLanguages(data.languages);
  };

  const loadUserPreference = async () => {
    // Detectar idioma del navegador
    const browserLang = navigator.language.split('-')[0];
    
    // Cargar preferencia guardada
    const response = await fetch(`/api/language-preference?token=${accessToken}`);
    const data = await response.json();
    
    if (data.preference) {
      setCurrentLang(data.preference.language_code);
    } else {
      // Usar idioma del navegador si est√° soportado
      const supported = ['es', 'en', 'fr', 'de', 'it', 'pt', 'ca', 'nl', 'zh', 'ja', 'ko', 'ru'];
      const detectedLang = supported.includes(browserLang) ? browserLang : 'en';
      setCurrentLang(detectedLang);
      
      // Guardar detecci√≥n autom√°tica
      saveLanguagePreference(detectedLang, false);
    }
  };

  const saveLanguagePreference = async (langCode: string, manual: boolean) => {
    await fetch('/api/language-preference', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        accessToken,
        languageCode: langCode,
        manuallySelected: manual,
        detectedLanguage: navigator.language.split('-')[0]
      })
    });
  };

  const handleLanguageChange = async (langCode: string) => {
    setIsLoading(true);
    setCurrentLang(langCode);
    setIsOpen(false);
    
    // Guardar preferencia
    await saveLanguagePreference(langCode, true);
    
    // Notificar al componente padre
    if (onLanguageChange) {
      onLanguageChange(langCode);
    }
    
    // Recargar p√°gina para aplicar traducciones
    window.location.reload();
    
    setIsLoading(false);
  };

  const currentLanguage = languages.find(l => l.code === currentLang);

  return (
    <div className="relative">
      {/* Bot√≥n selector */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center space-x-2 px-3 py-2 rounded-lg hover:bg-gray-100 transition-colors"
        disabled={isLoading}
      >
        {isLoading ? (
          <div className="animate-spin h-4 w-4 border-2 border-blue-500 border-t-transparent rounded-full" />
        ) : (
          <>
            <span className="text-xl">{currentLanguage?.flagEmoji || 'üåê'}</span>
            <span className="text-sm font-medium hidden sm:inline">
              {currentLanguage?.code.toUpperCase() || 'ES'}
            </span>
            <svg 
              className={`w-4 h-4 transition-transform ${isOpen ? 'rotate-180' : ''}`}
              fill="none" 
              stroke="currentColor" 
              viewBox="0 0 24 24"
            >
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
            </svg>
          </>
        )}
      </button>

      {/* Dropdown */}
      {isOpen && (
        <>
          {/* Overlay para cerrar al hacer click fuera */}
          <div 
            className="fixed inset-0 z-10" 
            onClick={() => setIsOpen(false)}
          />
          
          {/* Menu */}
          <div className="absolute right-0 mt-2 w-56 bg-white rounded-lg shadow-lg border border-gray-200 z-20 max-h-96 overflow-y-auto">
            <div className="p-2">
              <div className="px-3 py-2 text-xs font-semibold text-gray-500 uppercase tracking-wide">
                Selecciona idioma
              </div>
              
              {languages.map((lang) => (
                <button
                  key={lang.code}
                  onClick={() => handleLanguageChange(lang.code)}
                  className={`w-full flex items-center space-x-3 px-3 py-2 rounded-md hover:bg-gray-100 transition-colors ${
                    currentLang === lang.code ? 'bg-blue-50 text-blue-700' : 'text-gray-700'
                  }`}
                >
                  <span className="text-2xl">{lang.flagEmoji}</span>
                  <div className="flex-1 text-left">
                    <div className="font-medium">{lang.nativeName}</div>
                    <div className="text-xs text-gray-500">{lang.name}</div>
                  </div>
                  {currentLang === lang.code && (
                    <svg className="w-5 h-5 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
                      <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                    </svg>
                  )}
                </button>
              ))}
            </div>
            
            <div className="border-t border-gray-200 px-3 py-2 text-xs text-gray-500">
              üí° Las traducciones se guardan para una carga m√°s r√°pida
            </div>
          </div>
        </>
      )}
    </div>
  );
}

API DE TRADUCCI√ìN
Sistema de Traducci√≥n con Claude
typescript// lib/translator.ts

import Anthropic from '@anthropic-ai/sdk';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY!,
});

export class Translator {
  
  /**
   * Traduce un texto √∫nico
   */
  static async translateText(
    text: string,
    targetLang: string,
    sourceLang: string = 'es',
    context?: string
  ): Promise<string> {
    
    // 1. Buscar en cach√©
    const cached = await this.getCachedTranslation(
      text,
      targetLang,
      sourceLang
    );
    
    if (cached) {
      // Actualizar hits de cach√©
      await this.incrementCacheHits(cached.id);
      return cached.translated_text;
    }
    
    // 2. Traducir con Claude
    const prompt = `Traduce el siguiente texto de ${this.getLanguageName(sourceLang)} a ${this.getLanguageName(targetLang)}.

${context ? `CONTEXTO: ${context}\n\n` : ''}TEXTO A TRADUCIR:
${text}

INSTRUCCIONES:
- Traduce de forma natural y fluida
- Mant√©n el tono y la intenci√≥n del original
- Si hay t√©rminos t√©cnicos o nombres propios, mantenlos
- Si es una direcci√≥n o nombre de lugar, NO lo traduzcas
- Responde SOLO con la traducci√≥n, sin explicaciones

TRADUCCI√ìN:`;

    const message = await anthropic.messages.create({
      model: "claude-3-haiku-20240307", // M√°s barato para traducciones
      max_tokens: 2048,
      messages: [{
        role: "user",
        content: prompt
      }]
    });
    
    const translation = message.content[0].text.trim();
    
    // 3. Guardar en cach√©
    await this.cacheTranslation({
      sourceText: text,
      translatedText: translation,
      sourceLang,
      targetLang,
      tokensUsed: message.usage.input_tokens + message.usage.output_tokens,
      costUsd: this.calculateCost(message.usage)
    });
    
    return translation;
  }
  
  /**
   * Traduce un objeto completo (ej: restaurante, actividad)
   */
  static async translateObject(
    obj: any,
    sourceType: string,
    sourceId: string,
    targetLang: string,
    fieldsToTranslate: string[]
  ): Promise<any> {
    
    const translated = { ...obj };
    
    // Traducir cada campo en paralelo
    const translations = await Promise.all(
      fieldsToTranslate.map(async (field) => {
        if (!obj[field]) return null;
        
        const translation = await this.translateField(
          sourceType,
          sourceId,
          field,
          obj[field],
          targetLang
        );
        
        return { field, translation };
      })
    );
    
    // Aplicar traducciones
    translations.forEach(t => {
      if (t) {
        translated[t.field] = t.translation;
      }
    });
    
    return translated;
  }
  
  /**
   * Traduce un campo espec√≠fico con cach√© por campo
   */
  private static async translateField(
    sourceType: string,
    sourceId: string,
    field: string,
    text: string,
    targetLang: string
  ): Promise<string> {
    
    // Buscar en cach√© espec√≠fico del campo
    const { data: cached } = await supabase
      .from('translation_cache')
      .select('*')
      .eq('source_type', sourceType)
      .eq('source_id', sourceId)
      .eq('source_field', field)
      .eq('target_language', targetLang)
      .single();
    
    if (cached) {
      await this.incrementCacheHits(cached.id);
      return cached.translated_text;
    }
    
    // Traducir
    const context = this.getContextForType(sourceType);
    const translation = await this.translateText(text, targetLang, 'es', context);
    
    // Guardar en cach√© con metadatos espec√≠ficos
    await supabase
      .from('translation_cache')
      .insert({
        source_type: sourceType,
        source_id: sourceId,
        source_field: field,
        source_text: text,
        translated_text: translation,
        source_language: 'es',
        target_language: targetLang,
        translation_method: 'claude'
      });
    
    return translation;
  }
  
  /**
   * Traduce contenido estructurado en batch
   */
  static async translateBatch(
    items: Array<{
      type: string;
      id: string;
      fields: Record<string, string>;
    }>,
    targetLang: string
  ): Promise<any[]> {
    
    // Preparar batch de traducciones
    const batchPrompt = items.map(item => {
      const fields = Object.entries(item.fields)
        .map(([key, value]) => `${key}: ${value}`)
        .join('\n');
      
      return `[${item.type}:${item.id}]\n${fields}\n---`;
    }).join('\n\n');
    
    const prompt = `Traduce el siguiente contenido estructurado de espa√±ol a ${this.getLanguageName(targetLang)}.

Mant√©n EXACTAMENTE el mismo formato con los identificadores [tipo:id] y las claves de campo.

CONTENIDO:
${batchPrompt}

TRADUCCI√ìN:`;

    const message = await anthropic.messages.create({
      model: "claude-3-haiku-20240307",
      max_tokens: 4096,
      messages: [{
        role: "user",
        content: prompt
      }]
    });
    
    // Parsear respuesta estructurada
    return this.parseBatchResponse(message.content[0].text, items);
  }
  
  // M√©todos auxiliares
  
  private static async getCachedTranslation(
    text: string,
    targetLang: string,
    sourceLang: string
  ) {
    const { data } = await supabase
      .from('translation_cache')
      .select('*')
      .eq('source_text', text)
      .eq('target_language', targetLang)
      .eq('source_language', sourceLang)
      .single();
    
    return data;
  }
  
  private static async cacheTranslation(data: any) {
    await supabase
      .from('translation_cache')
      .insert({
        source_type: 'text',
        source_id: createHash('md5').update(data.sourceText).digest('hex'),
        source_text: data.sourceText,
        translated_text: data.translatedText,
        source_language: data.sourceLang,
        target_language: data.targetLang,
        tokens_used: data.tokensUsed,
        cost_usd: data.costUsd
      });
  }
  
  private static async incrementCacheHits(cacheId: string) {
    await supabase.rpc('increment_cache_hits', { cache_id: cacheId });
  }
  
  private static calculateCost(usage: any): number {
    // Claude Haiku pricing: $0.25 / 1M input, $1.25 / 1M output
    const inputCost = (usage.input_tokens / 1_000_000) * 0.25;
    const outputCost = (usage.output_tokens / 1_000_000) * 1.25;
    return inputCost + outputCost;
  }
  
  private static getLanguageName(code: string): string {
    const names: Record<string, string> = {
      es: 'espa√±ol',
      en: 'ingl√©s',
      fr: 'franc√©s',
      de: 'alem√°n',
      it: 'italiano',
      pt: 'portugu√©s',
      ca: 'catal√°n',
      nl: 'holand√©s',
      zh: 'chino',
      ja: 'japon√©s',
      ko: 'coreano',
      ru: 'ruso'
    };
    return names[code] || code;
  }
  
  private static getContextForType(type: string): string {
    const contexts: Record<string, string> = {
      restaurant: 'Informaci√≥n sobre un restaurante para hu√©spedes tur√≠sticos',
      activity: 'Descripci√≥n de una actividad o atracci√≥n tur√≠stica',
      transport: 'Instrucciones de transporte p√∫blico',
      house_rules: 'Normas de una casa de alquiler vacacional',
      manual: 'Manual de uso de un electrodom√©stico'
    };
    return contexts[type] || 'Contenido para gu√≠a tur√≠stica';
  }
  
  private static parseBatchResponse(response: string, originalItems: any[]): any[] {
    // Implementar parsing del formato estructurado
    // Por simplicidad, usar regex para extraer bloques [tipo:id]
    const blocks = response.split('---').map(b => b.trim());
    
    return originalItems.map((item, idx) => {
      const block = blocks[idx];
      if (!block) return item;
      
      const lines = block.split('\n').filter(l => l.includes(':'));
      const translated: Record<string, string> = {};
      
      lines.forEach(line => {
        const [key, ...valueParts] = line.split(':');
        const value = valueParts.join(':').trim();
        if (key && value) {
          translated[key.trim()] = value;
        }
      });
      
      return {
        ...item,
        fields: translated
      };
    });
  }
}

// Funci√≥n SQL helper para incrementar cache hits
CREATE OR REPLACE FUNCTION increment_cache_hits(cache_id UUID)
RETURNS void AS $$
BEGIN
  UPDATE translation_cache
  SET 
    cache_hits = cache_hits + 1,
    last_used_at = NOW()
  WHERE id = cache_id;
END;
$$ LANGUAGE plpgsql;

API ROUTES
Obtener idiomas disponibles
typescript// app/api/languages/route.ts

export async function GET() {
  const { data: languages } = await supabase
    .from('supported_languages')
    .select('*')
    .eq('is_active', true)
    .order('code');
  
  return Response.json({ languages });
}
Guardar/Obtener preferencia de idioma
typescript// app/api/language-preference/route.ts

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const token = searchParams.get('token');
  
  const { data: preference } = await supabase
    .from('guest_language_preferences')
    .select('*')
    .eq('access_token', token)
    .single();
  
  return Response.json({ preference });
}

export async function POST(req: Request) {
  const { 
    accessToken, 
    languageCode, 
    manuallySelected,
    detectedLanguage 
  } = await req.json();
  
  const { data, error } = await supabase
    .from('guest_language_preferences')
    .upsert({
      access_token: accessToken,
      language_code: languageCode,
      manually_selected: manuallySelected,
      detected_language: detectedLanguage,
      updated_at: new Date()
    }, {
      onConflict: 'access_token'
    })
    .select()
    .single();
  
  return Response.json({ preference: data });
}
Traducir contenido de la gu√≠a
typescript// app/api/translate-guide/route.ts

export async function POST(req: Request) {
  const { accessToken, targetLanguage } = await req.json();
  
  // 1. Validar acceso
  const { data: access } = await supabase
    .from('guest_access_tokens')
    .select('property_id')
    .eq('access_token', accessToken)
    .single();
  
  if (!access) {
    return Response.json({ error: 'Unauthorized' }, { status: 403 });
  }
  
  // 2. Obtener todo el contenido de la propiedad
  const { data: context } = await supabase
    .from('property_context')
    .select('*')
    .eq('property_id', access.property_id)
    .single();
  
  // 3. Traducir restaurantes
  const translatedRestaurants = await Promise.all(
    (context.restaurants || []).map(async (restaurant: any) => {
      return await Translator.translateObject(
        restaurant,
        'restaurant',
        restaurant.name,
        targetLanguage,
        ['specialty', 'description', 'personal_note']
        // NO traducir: name, address (son nombres propios)
      );
    })
  );
  
  // 4. Traducir actividades
  const translatedActivities = await Promise.all(
    (context.activities || []).map(async (activity: any) => {
      return await Translator.translateObject(
        activity,
        'activity',
        activity.name,
        targetLanguage,
        ['description', 'estimated_time']
      );
    })
  );
  
  // 5. Traducir transporte
  const translatedTransport = {
    ...context.transport,
    from_airport: {
      metro: {
        ...context.transport.from_airport.metro,
        route: await Translator.translateText(
          context.transport.from_airport.metro.route,
          targetLanguage,
          'es',
          'Instrucciones de ruta de metro'
        )
      },
      taxi: context.transport.from_airport.taxi,
      bus: context.transport.from_airport.bus
    }
  };
  
  // 6. Traducir tips locales
  const translatedTips = await Promise.all(
    (context.local_tips || []).map((tip: string) =>
      Translator.translateText(tip, targetLanguage, 'es', 'Consejo local para turistas')
    )
  );
  
  // 7. Retornar contenido traducido
  return Response.json({
    restaurants: translatedRestaurants,
    activities: translatedActivities,
    transport: translatedTransport,
    localTips: translatedTips,
    language: targetLanguage
  });
}

HOOK PERSONALIZADO PARA TRADUCCIONES
typescript// hooks/useTranslation.ts
'use client';

import { useState, useEffect, createContext, useContext } from 'react';

interface TranslationContextType {
  language: string;
  setLanguage: (lang: string) => void;
  t: (key: string, fallback?: string) => string;
  translateContent: (content: any) => any;
  isLoading: boolean;
}

const TranslationContext = createContext<TranslationContextType | null>(null);

export function TranslationProvider({ 
  children, 
  accessToken,
  initialLanguage = 'es' 
}: { 
  children: React.ReactNode;
  accessToken: string;
  initialLanguage?: string;
}) {
  const [language, setLanguage] = useState(initialLanguage);
  const [translations, setTranslations] = useState<Record<string, any>>({});
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    loadTranslations(language);
  }, [language]);

  const loadTranslations = async (lang: string) => {
    if (lang === 'es') {
      setTranslations({});
      return; // Espa√±ol es el idioma base
    }

    setIsLoading(true);
    
    try {
      const response = await fetch('/api/translate-guide', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          accessToken,
          targetLanguage: lang
        })
      });
      
      const data = await response.json();
      setTranslations(data);
    } catch (error) {
      console.error('Error loading translations:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const t = (key: string, fallback?: string) => {
    if (language === 'es') return fallback || key;
    
    const keys = key.split('.');
    let value = translations;
    
    for (const k of keys) {
      if (value && typeof value === 'object') {
        value = value[k];
      } else {
        return fallback || key;
      }
    }
    
    return typeof value === 'string' ? value : fallback || key;
  };

  const translateContent = (content: any) => {
    if (language === 'es') return content;
    
    // Aplicar traducciones al contenido
    return {
      ...content,
      restaurants: translations.restaurants || content.restaurants,
      activities: translations.activities || content.activities,
      transport: translations.transport || content.transport,
      localTips: translations.localTips || content.localTips
    };
  };

  return (
    <TranslationContext.Provider value={{
      language,
      setLanguage,
      t,
      translateContent,
      isLoading
    }}>
      {children}
    </TranslationContext.Provider>
  );
}

export function useTranslation() {
  const context = useContext(TranslationContext);
  if (!context) {
    throw new Error('useTranslation must be used within TranslationProvider');
  }
  return context;
}

INTEGRACI√ìN EN LA GU√çA
Layout de la gu√≠a con traducciones
typescript// app/g/[token]/layout.tsx

import { TranslationProvider } from '@/hooks/useTranslation';
import LanguageSelector from '@/components/LanguageSelector';

export default async function GuideLayout({
  children,
  params
}: {
  children: React.ReactNode;
  params: { token: string };
}) {
  
  // Detectar idioma preferido
  const { data: preference } = await supabase
    .from('guest_language_preferences')
    .select('language_code')
    .eq('access_token', params.token)
    .single();
  
  const initialLanguage = preference?.language_code || 'es';
  
  return (
    <TranslationProvider 
      accessToken={params.token}
      initialLanguage={initialLanguage}
    >
      <div className="min-h-screen bg-gray-50">
        {/* Header con selector de idioma */}
        <header className="bg-white border-b sticky top-0 z-50">
          <div className="max-w-4xl mx-auto px-4 py-3 flex justify-between items-center">
            <h1 className="text-lg font-semibold">Mi Gu√≠a</h1>
            <LanguageSelector accessToken={params.token} />
          </div>
        </header>
        
        {/* Contenido */}
        <main>
          {children}
        </main>
      </div>
    </TranslationProvider>
  );
}
Uso en componentes
typescript// app/g/[token]/restaurants/page.tsx
'use client';

import { useTranslation } from '@/hooks/useTranslation';

export default function RestaurantsPage({ data }: { data: any }) {
  const { translateContent, isLoading, language } = useTranslation();
  
  const content = translateContent(data);
  
  if (isLoading) {
    return <LoadingSpinner />;
  }
  
  return (
    <div>
      <h2>{language === 'es' ? 'D√≥nde Comer' : 'Where to Eat'}</h2>
      
      {content.restaurants.map((restaurant: any) => (
        <RestaurantCard 
          key={restaurant.name}
          name={restaurant.name} // Nombre NO se traduce
          specialty={restaurant.specialty} // S√ç traducido
          description={restaurant.description} // S√ç traducido
          price={restaurant.price_range}
        />
      ))}
    </div>
  );
}

TRADUCCIONES DEL CHAT
Chat multilenguaje
typescript// app/api/chat/route.ts

export async function POST(req: Request) {
  const { messages, accessToken, language } = await req.json();
  
  const lastMessage = messages[messages.length - 1].content;
  
  // 1. Detectar si el mensaje est√° en otro idioma
  const messageLanguage = language || 'es';
  
  // 2. Si no es espa√±ol, traducir pregunta a espa√±ol para RAG
  let queryForRAG = lastMessage;
  if (messageLanguage !== 'es') {
    queryForRAG = await Translator.translateText(
      lastMessage,
      'es',
      messageLanguage,
      'Pregunta de un hu√©sped sobre el apartamento'
    );
  }
  
  // 3. Hacer RAG en espa√±ol (tu l√≥gica existente)
  const { data: relevantChunks } = await supabase.rpc('match_all_context', {
    query_embedding: await generateEmbedding(queryForRAG),
    // ... resto de par√°metros
  });
  
  const context = relevantChunks?.map(c => c.content).join('\n\n');
  
  // 4. Generar respuesta con Claude
  const systemPrompt = messageLanguage === 'es' 
    ? `Eres un asistente para hu√©spedes. Responde en espa√±ol...`
    : `You are a guest assistant. Respond in ${Translator.getLanguageName(messageLanguage)}...

IMPORTANT: Your response must be in ${Translator.getLanguageName(messageLanguage)}, not in Spanish.

CONTEXT (in Spanish - translate key information):
${context}

GUEST QUESTION (in ${Translator.getLanguageName(messageLanguage)}):
${lastMessage}

Provide a helpful answer in ${Translator.getLanguageName(messageLanguage)}.`;

  const stream = await anthropic.messages.stream({
    model: "claude-3-haiku-20240307",
    max_tokens: 1024,
    messages: [{ role: 'user', content: systemPrompt }]
  });
  
  // Retornar stream en el idioma solicitado
  return new StreamingTextResponse(stream);
}

ETIQUETAS DE UI EST√ÅTICAS
Archivo de traducciones para UI
typescript// locales/translations.ts

export const translations = {
  es: {
    common: {
      loading: 'Cargando...',
      error: 'Error',
      save: 'Guardar',
      cancel: 'Cancelar',
      close: 'Cerrar'
    },
    guide: {
      welcome: 'Bienvenido/a',
      essential: 'Lo Esencial',
      howToEnter: 'C√≥mo Entrar',
      wifi: 'WiFi',
      askMe: 'Preg√∫ntame',
      contact: 'Contacto',
      whereToEat: 'D√≥nde Comer',
      whatToDo: 'Qu√© Hacer',
      howToMove: 'C√≥mo Moverte',
      theApartment: 'El Apartamento'
    },
    chat: {
      placeholder: 'Escribe tu pregunta...',
      send: 'Enviar',
      thinking: 'Pensando...'
    }
  },
  
  en: {
    common: {
      loading: 'Loading...',
      error: 'Error',
      save: 'Save',
      cancel: 'Cancel',
      close: 'Close'
    },
    guide: {
      welcome: 'Welcome',
      essential: 'Essentials',
      howToEnter: 'How to Enter',
      wifi: 'WiFi',
      askMe: 'Ask Me',
      contact: 'Contact',
      whereToEat: 'Where to Eat',
      whatToDo: 'What to Do',
      howToMove: 'Getting Around',
      theApartment: 'The Apartment'
    },
    chat: {
      placeholder: 'Type your question...',
      send: 'Send',
      thinking: 'Thinking...'
    }
  },
  
  fr: {
    common: {
      loading: 'Chargement...',
      error: 'Erreur',
      save: 'Enregistrer',
      cancel: 'Annuler',
      close: 'Fermer'
    },
    guide: {
      welcome: 'Bienvenue',
      essential: 'L\'Essentiel',
      howToEnter: 'Comment Entrer',
      wifi: 'WiFi',
      askMe: 'Demandez-moi',
      contact: 'Contact',
      whereToEat: 'O√π Manger',
      whatToDo: 'Que Faire',
      howToMove: 'Se D√©placer',
      theApartment: 'L\'Appartement'
    },
    chat: {
      placeholder: 'Tapez votre question...',
      send: 'Envoyer',
      thinking: 'R√©flexion...'
    }
  }
  
  // ... m√°s idiomas
};

export function getTranslation(lang: string, key: string): string {
  const keys = key.split('.');
  let value: any = translations[lang as keyof typeof translations] || translations.es;
  
  for (const k of keys) {
    value = value?.[k];
  }
  
  return typeof value === 'string' ? value : key;
}

OPTIMIZACI√ìN: PRE-TRADUCCI√ìN EN BACKGROUND
Job para pre-traducir contenido popular
typescript// jobs/pre-translate-properties.ts

/**
 * Job que se ejecuta 1 vez al d√≠a para pre-traducir
 * el contenido de propiedades activas a los idiomas m√°s comunes
 */

import { Translator } from '@/lib/translator';

const PRIORITY_LANGUAGES = ['en', 'fr', 'de', 'it'];

export async function preTranslateProperties() {
  // Obtener propiedades con reservas activas o pr√≥ximas
  const { data: activeProperties } = await supabase
    .from('guest_access_tokens')
    .select('property_id')
    .gte('valid_until', new Date())
    .eq('is_active', true);
  
  const propertyIds = [...new Set(activeProperties?.map(a => a.property_id))];
  
  for (const propertyId of propertyIds) {
    await preTranslateProperty(propertyId);
  }
}

async function preTranslateProperty(propertyId: string) {
  const { data: context } = await supabase
    .from('property_context')
    .select('*')
    .eq('property_id', propertyId)
    .single();
  
  if (!context) return;
  
  for (const lang of PRIORITY_LANGUAGES) {
    // Verificar si ya est√° traducido
    const { count } = await supabase
      .from('translation_cache')
      .select('*', { count: 'exact', head: true })
      .eq('source_id', propertyId)
      .eq('target_language', lang);
    
    if (count && count > 0) continue; // Ya traducido
    
    // Traducir en batch
    const items = [
      ...context.restaurants.map((r: any) => ({
        type: 'restaurant',
        id: r.name,
        fields: {
          specialty: r.specialty,
          description: r.description || '',
          personal_note: r.personal_note || ''
        }
      })),
      ...context.activities.map((a: any) => ({
        type: 'activity',
        id: a.name,
        fields: {
          description: a.description
        }
      }))
    ];
    
    await Translator.translateBatch(items, lang);
    
    console.log(`Pre-translated ${propertyId} to ${lang}`);
  }
}

// Ejecutar cada noche a las 2 AM
// Usar cron job o Vercel Cron

ANALYTICS DE TRADUCCI√ìN
Dashboard para el host
typescript// app/dashboard/translations/page.tsx

export default function TranslationsAnalytics() {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">Analytics de Traducciones</h1>
      
      {/* Idiomas m√°s usados */}
      <div className="bg-white rounded-lg shadow p-6 mb-6">
        <h2 className="text-lg font-semibold mb-4">Idiomas de tus Hu√©spedes</h2>
        
        <div className="space-y-3">
          <div className="flex items-center">
            <span className="text-2xl mr-3">üá¨üáß</span>
            <div className="flex-1">
              <div className="flex justify-between mb-1">
                <span className="font-medium">English</span>
                <span className="text-gray-600">45%</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-2">
                <div className="bg-blue-500 h-2 rounded-full" style={{ width: '45%' }} />
              </div>
            </div>
          </div>
          
          <div className="flex items-center">
            <span className="text-2xl mr-3">üá´üá∑</span>
            <div className="flex-1">
              <div className="flex justify-between mb-1">
                <span className="font-medium">Fran√ßais</span>
                <span className="text-gray-600">30%</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-2">
                <div className="bg-blue-500 h-2 rounded-full" style={{ width: '30%' }} />
              </div>
            </div>
          </div>
          
          {/* M√°s idiomas... */}
        </div>
      </div>
      
      {/* Costes */}
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-lg font-semibold mb-4">Coste de Traducciones</h2>
        
        <div className="grid grid-cols-3 gap-4">
          <div className="text-center p-4 bg-gray-50 rounded-lg">
            <div className="text-2xl font-bold text-blue-600">$2.40</div>
            <div className="text-sm text-gray-600">Este mes</div>
          </div>
          
          <div className="text-center p-4 bg-gray-50 rounded-lg">
            <div className="text-2xl font-bold text-green-600">87%</div>
            <div className="text-sm text-gray-600">Desde cach√©</div>
          </div>
          
          <div className="text-center p-4 bg-gray-50 rounded-lg">
            <div className="text-2xl font-bold text-purple-600">1,243</div>
            <div className="text-sm text-gray-600">Traducciones</div>
          </div>
        </div>
      </div>
    </div>
  );
}