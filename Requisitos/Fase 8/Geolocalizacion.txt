Estrategia de Geolocalizaci√≥n Sin Fricci√≥n
Excelente punto. La precisi√≥n de ubicaci√≥n es cr√≠tica para generar rutas. Aqu√≠ est√° mi soluci√≥n:

üéØ ESTRATEGIA: AUTO-GEOCODING INTELIGENTE
Datos M√≠nimos del Propietario:
yamlsetup_propiedad:
  # SOLO PIDE ESTO (ya lo tienes)
  direccion_completa: "Calle Mayor 123, 3¬∫ B, 28013 Madrid"
  
  # TODO LO DEM√ÅS SE OBTIENE AUTOM√ÅTICAMENTE

ü§ñ SISTEMA AUTOM√ÅTICO DE GEOCODING
Paso 1: Al guardar la direcci√≥n
typescript// app/api/properties/create/route.ts

export async function POST(req: Request) {
  const { address } = await req.json();
  
  // 1. GEOCODING AUTOM√ÅTICO con m√∫ltiples servicios (fallback)
  const location = await geocodeAddress(address);
  
  // 2. VALIDACI√ìN INTELIGENTE
  const validation = await validateLocation(location, address);
  
  // 3. GUARDAR TODO
  const { data: property } = await supabase
    .from('properties')
    .insert({
      address: address,
      
      // Coordenadas exactas
      latitude: location.lat,
      longitude: location.lng,
      
      // Contexto geogr√°fico (auto-extra√≠do)
      city: location.city,
      country: location.country,
      postal_code: location.postalCode,
      neighborhood: location.neighborhood,
      
      // Datos adicionales √∫tiles
      timezone: location.timezone, // "Europe/Madrid"
      country_code: location.countryCode, // "ES"
      
      // Metadata para validaci√≥n
      geocoding_confidence: location.confidence, // 0-1
      geocoding_source: location.source, // "google" | "mapbox" | "nominatim"
      geocoding_accuracy: location.accuracy, // "rooftop" | "street" | "city"
      
      created_at: new Date()
    })
    .select()
    .single();
  
  return Response.json({ 
    property,
    location,
    needsReview: validation.confidence < 0.8
  });
}

üìç IMPLEMENTACI√ìN DEL GEOCODER
Sistema Multi-Proveedor con Fallback
typescript// lib/geocoding.ts

interface GeocodingResult {
  lat: number;
  lng: number;
  city: string;
  country: string;
  countryCode: string;
  postalCode?: string;
  neighborhood?: string;
  timezone: string;
  confidence: number; // 0-1
  accuracy: 'rooftop' | 'street' | 'city' | 'region';
  source: 'google' | 'mapbox' | 'nominatim';
  formattedAddress: string;
}

export async function geocodeAddress(address: string): Promise<GeocodingResult> {
  // Intentar en orden de calidad/costo
  
  // 1. GOOGLE MAPS (mejor calidad, pero de pago)
  try {
    return await geocodeWithGoogle(address);
  } catch (error) {
    console.log('Google geocoding failed, trying Mapbox...');
  }
  
  // 2. MAPBOX (buena calidad, 100k gratis/mes)
  try {
    return await geocodeWithMapbox(address);
  } catch (error) {
    console.log('Mapbox geocoding failed, trying Nominatim...');
  }
  
  // 3. NOMINATIM (OpenStreetMap - gratis pero limitado)
  try {
    return await geocodeWithNominatim(address);
  } catch (error) {
    throw new Error('All geocoding services failed');
  }
}

// === GOOGLE MAPS GEOCODING ===
async function geocodeWithGoogle(address: string): Promise<GeocodingResult> {
  const apiKey = process.env.GOOGLE_MAPS_API_KEY;
  
  if (!apiKey) throw new Error('Google API key not configured');
  
  const response = await fetch(
    `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${apiKey}`
  );
  
  const data = await response.json();
  
  if (data.status !== 'OK' || !data.results[0]) {
    throw new Error(`Google geocoding failed: ${data.status}`);
  }
  
  const result = data.results[0];
  const components = result.address_components;
  
  return {
    lat: result.geometry.location.lat,
    lng: result.geometry.location.lng,
    city: extractComponent(components, 'locality'),
    country: extractComponent(components, 'country'),
    countryCode: extractComponent(components, 'country', 'short_name'),
    postalCode: extractComponent(components, 'postal_code'),
    neighborhood: extractComponent(components, 'neighborhood') || 
                  extractComponent(components, 'sublocality'),
    timezone: await getTimezone(result.geometry.location.lat, result.geometry.location.lng),
    confidence: getGoogleConfidence(result.geometry.location_type),
    accuracy: mapGoogleAccuracy(result.geometry.location_type),
    source: 'google',
    formattedAddress: result.formatted_address
  };
}

function extractComponent(
  components: any[], 
  type: string, 
  format: 'long_name' | 'short_name' = 'long_name'
): string {
  const component = components.find(c => c.types.includes(type));
  return component?.[format] || '';
}

function mapGoogleAccuracy(locationType: string): GeocodingResult['accuracy'] {
  switch (locationType) {
    case 'ROOFTOP': return 'rooftop';
    case 'RANGE_INTERPOLATED': return 'street';
    case 'GEOMETRIC_CENTER': return 'city';
    default: return 'region';
  }
}

function getGoogleConfidence(locationType: string): number {
  switch (locationType) {
    case 'ROOFTOP': return 1.0;
    case 'RANGE_INTERPOLATED': return 0.8;
    case 'GEOMETRIC_CENTER': return 0.6;
    default: return 0.4;
  }
}

// === MAPBOX GEOCODING ===
async function geocodeWithMapbox(address: string): Promise<GeocodingResult> {
  const apiKey = process.env.MAPBOX_API_KEY;
  
  if (!apiKey) throw new Error('Mapbox API key not configured');
  
  const response = await fetch(
    `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(address)}.json?access_token=${apiKey}&limit=1`
  );
  
  const data = await response.json();
  
  if (!data.features || data.features.length === 0) {
    throw new Error('Mapbox geocoding returned no results');
  }
  
  const result = data.features[0];
  const [lng, lat] = result.center;
  
  // Extraer contexto
  const context = result.context || [];
  const postcode = context.find((c: any) => c.id.startsWith('postcode'));
  const place = context.find((c: any) => c.id.startsWith('place'));
  const country = context.find((c: any) => c.id.startsWith('country'));
  const neighborhood = context.find((c: any) => c.id.startsWith('neighborhood'));
  
  return {
    lat,
    lng,
    city: place?.text || '',
    country: country?.text || '',
    countryCode: country?.short_code?.toUpperCase() || '',
    postalCode: postcode?.text,
    neighborhood: neighborhood?.text,
    timezone: await getTimezone(lat, lng),
    confidence: result.relevance || 0.5,
    accuracy: mapMapboxAccuracy(result.place_type),
    source: 'mapbox',
    formattedAddress: result.place_name
  };
}

function mapMapboxAccuracy(placeTypes: string[]): GeocodingResult['accuracy'] {
  if (placeTypes.includes('address')) return 'rooftop';
  if (placeTypes.includes('street')) return 'street';
  if (placeTypes.includes('place')) return 'city';
  return 'region';
}

// === NOMINATIM (OpenStreetMap) ===
async function geocodeWithNominatim(address: string): Promise<GeocodingResult> {
  // IMPORTANTE: Nominatim requiere User-Agent
  const response = await fetch(
    `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(address)}&format=json&addressdetails=1&limit=1`,
    {
      headers: {
        'User-Agent': 'GuestGuideApp/1.0' // REQUERIDO
      }
    }
  );
  
  const data = await response.json();
  
  if (!data || data.length === 0) {
    throw new Error('Nominatim geocoding returned no results');
  }
  
  const result = data[0];
  
  return {
    lat: parseFloat(result.lat),
    lng: parseFloat(result.lon),
    city: result.address.city || result.address.town || result.address.village || '',
    country: result.address.country || '',
    countryCode: result.address.country_code?.toUpperCase() || '',
    postalCode: result.address.postcode,
    neighborhood: result.address.neighbourhood || result.address.suburb,
    timezone: await getTimezone(parseFloat(result.lat), parseFloat(result.lon)),
    confidence: parseFloat(result.importance) || 0.5,
    accuracy: mapNominatimAccuracy(result.type),
    source: 'nominatim',
    formattedAddress: result.display_name
  };
}

function mapNominatimAccuracy(type: string): GeocodingResult['accuracy'] {
  if (['house', 'building'].includes(type)) return 'rooftop';
  if (['street', 'road'].includes(type)) return 'street';
  if (['city', 'town', 'village'].includes(type)) return 'city';
  return 'region';
}

// === TIMEZONE (usando Google o alternativa) ===
async function getTimezone(lat: number, lng: number): Promise<string> {
  // Opci√≥n 1: Google Timezone API (de pago pero preciso)
  if (process.env.GOOGLE_MAPS_API_KEY) {
    try {
      const timestamp = Math.floor(Date.now() / 1000);
      const response = await fetch(
        `https://maps.googleapis.com/maps/api/timezone/json?location=${lat},${lng}&timestamp=${timestamp}&key=${process.env.GOOGLE_MAPS_API_KEY}`
      );
      const data = await response.json();
      if (data.status === 'OK') {
        return data.timeZoneId;
      }
    } catch (error) {
      console.error('Google Timezone API failed');
    }
  }
  
  // Opci√≥n 2: Aproximaci√≥n por pa√≠s (fallback)
  return 'Europe/Madrid'; // Default para Espa√±a
}

‚úÖ VALIDACI√ìN INTELIGENTE
Sistema que detecta posibles errores
typescript// lib/geocoding-validation.ts

interface ValidationResult {
  isValid: boolean;
  confidence: number;
  warnings: string[];
  suggestions?: string[];
}

export async function validateLocation(
  location: GeocodingResult,
  originalAddress: string
): Promise<ValidationResult> {
  
  const warnings: string[] = [];
  const suggestions: string[] = [];
  
  // 1. Verificar confianza del geocoding
  if (location.confidence < 0.5) {
    warnings.push('Baja confianza en la ubicaci√≥n detectada');
    suggestions.push('Verifica que la direcci√≥n est√© completa');
  }
  
  // 2. Verificar precisi√≥n
  if (location.accuracy === 'city' || location.accuracy === 'region') {
    warnings.push('Ubicaci√≥n no es precisa (nivel ciudad/regi√≥n)');
    suggestions.push('A√±ade n√∫mero de calle y piso/puerta');
  }
  
  // 3. Verificar coherencia de direcci√≥n
  const addressLower = originalAddress.toLowerCase();
  
  if (!addressLower.includes(location.city.toLowerCase())) {
    warnings.push('La ciudad detectada no coincide con la direcci√≥n');
  }
  
  // 4. Verificar si est√° en zona poblada (no en medio del campo)
  if (location.accuracy === 'rooftop' && !location.neighborhood) {
    warnings.push('No se detect√≥ vecindario, puede estar en zona aislada');
  }
  
  // 5. Usar Claude para validaci√≥n sem√°ntica
  const semanticValidation = await validateWithAI(location, originalAddress);
  if (!semanticValidation.isValid) {
    warnings.push(...semanticValidation.warnings);
  }
  
  return {
    isValid: warnings.length === 0,
    confidence: location.confidence,
    warnings,
    suggestions: suggestions.length > 0 ? suggestions : undefined
  };
}

async function validateWithAI(
  location: GeocodingResult,
  originalAddress: string
): Promise<{ isValid: boolean; warnings: string[] }> {
  
  const prompt = `Analiza si esta ubicaci√≥n geocodificada es coherente:

DIRECCI√ìN ORIGINAL: ${originalAddress}

RESULTADO GEOCODING:
- Ciudad: ${location.city}
- Pa√≠s: ${location.country}
- Coordenadas: ${location.lat}, ${location.lng}
- Direcci√≥n formateada: ${location.formattedAddress}
- Confianza: ${location.confidence}

¬øEs coherente? Responde en JSON:
{
  "is_valid": true/false,
  "warnings": ["lista de advertencias si hay problemas"],
  "explanation": "breve explicaci√≥n"
}`;

  const message = await anthropic.messages.create({
    model: "claude-3-haiku-20240307",
    max_tokens: 512,
    messages: [{ role: "user", content: prompt }]
  });
  
  const result = JSON.parse(message.content[0].text);
  
  return {
    isValid: result.is_valid,
    warnings: result.warnings || []
  };
}

üé® UI DE CONFIRMACI√ìN PARA EL PROPIETARIO
Despu√©s del geocoding autom√°tico, mostrar esto:
typescript// components/LocationConfirmation.tsx

export default function LocationConfirmation({ 
  location, 
  validation 
}: { 
  location: GeocodingResult;
  validation: ValidationResult;
}) {
  
  return (
    <div className="bg-white rounded-lg shadow-lg p-6">
      <h3 className="text-lg font-semibold mb-4">
        Confirma la ubicaci√≥n de tu propiedad
      </h3>
      
      {/* Mapa interactivo */}
      <div className="mb-4">
        <MapPreview 
          lat={location.lat} 
          lng={location.lng}
          draggable={true} // El propietario puede ajustar
          onPositionChange={(newLat, newLng) => {
            // Actualizar coordenadas si mueve el pin
          }}
        />
        <p className="text-xs text-gray-500 mt-2">
          üí° Puedes mover el pin si la ubicaci√≥n no es exacta
        </p>
      </div>
      
      {/* Datos detectados */}
      <div className="bg-gray-50 rounded-lg p-4 mb-4">
        <h4 className="font-medium mb-2">üìç Datos detectados:</h4>
        <dl className="space-y-1 text-sm">
          <div className="flex justify-between">
            <dt className="text-gray-600">Ciudad:</dt>
            <dd className="font-medium">{location.city}</dd>
          </div>
          <div className="flex justify-between">
            <dt className="text-gray-600">C√≥digo postal:</dt>
            <dd className="font-medium">{location.postalCode || 'No detectado'}</dd>
          </div>
          <div className="flex justify-between">
            <dt className="text-gray-600">Vecindario:</dt>
            <dd className="font-medium">{location.neighborhood || 'No detectado'}</dd>
          </div>
          <div className="flex justify-between">
            <dt className="text-gray-600">Precisi√≥n:</dt>
            <dd>
              <span className={`inline-block px-2 py-1 rounded text-xs font-medium ${
                location.accuracy === 'rooftop' ? 'bg-green-100 text-green-800' :
                location.accuracy === 'street' ? 'bg-yellow-100 text-yellow-800' :
                'bg-orange-100 text-orange-800'
              }`}>
                {location.accuracy === 'rooftop' ? '‚úÖ Exacta' :
                 location.accuracy === 'street' ? '‚ö†Ô∏è Calle' :
                 '‚ö†Ô∏è Aproximada'}
              </span>
            </dd>
          </div>
        </dl>
      </div>
      
      {/* Advertencias */}
      {validation.warnings.length > 0 && (
        <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
          <h4 className="font-medium text-yellow-900 mb-2">‚ö†Ô∏è Advertencias:</h4>
          <ul className="text-sm text-yellow-800 space-y-1">
            {validation.warnings.map((warning, idx) => (
              <li key={idx}>‚Ä¢ {warning}</li>
            ))}
          </ul>
          
          {validation.suggestions && (
            <div className="mt-3 pt-3 border-t border-yellow-200">
              <p className="text-sm font-medium text-yellow-900 mb-1">
                üí° Sugerencias:
              </p>
              <ul className="text-sm text-yellow-800 space-y-1">
                {validation.suggestions.map((sug, idx) => (
                  <li key={idx}>‚Ä¢ {sug}</li>
                ))}
              </ul>
            </div>
          )}
        </div>
      )}
      
      {/* Botones */}
      <div className="flex space-x-3">
        <button
          onClick={() => handleConfirm(location)}
          className="flex-1 bg-blue-600 text-white font-semibold py-3 rounded-lg hover:bg-blue-700"
        >
          ‚úÖ Confirmar ubicaci√≥n
        </button>
        <button
          onClick={() => handleEditManually()}
          className="px-4 py-3 border border-gray-300 rounded-lg hover:bg-gray-50"
        >
          ‚úèÔ∏è Editar
        </button>
      </div>
      
      {/* Modo manual (si el auto fall√≥) */}
      {validation.confidence < 0.5 && (
        <button
          onClick={() => showManualInput()}
          className="w-full mt-3 text-sm text-gray-600 hover:text-gray-800"
        >
          üìù Introducir coordenadas manualmente
        </button>
      )}
    </div>
  );
}

üó∫Ô∏è COMPONENTE DE MAPA INTERACTIVO
Usando Mapbox (gratis hasta buen volumen)
typescript// components/MapPreview.tsx
'use client';

import { useEffect, useRef, useState } from 'react';
import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';

mapboxgl.accessToken = process.env.NEXT_PUBLIC_MAPBOX_TOKEN!;

export default function MapPreview({
  lat,
  lng,
  draggable = false,
  onPositionChange
}: {
  lat: number;
  lng: number;
  draggable?: boolean;
  onPositionChange?: (lat: number, lng: number) => void;
}) {
  const mapContainer = useRef<HTMLDivElement>(null);
  const map = useRef<mapboxgl.Map | null>(null);
  const marker = useRef<mapboxgl.Marker | null>(null);
  
  useEffect(() => {
    if (!mapContainer.current) return;
    
    // Inicializar mapa
    map.current = new mapboxgl.Map({
      container: mapContainer.current,
      style: 'mapbox://styles/mapbox/streets-v12',
      center: [lng, lat],
      zoom: 16
    });
    
    // A√±adir marcador
    marker.current = new mapboxgl.Marker({
      draggable: draggable,
      color: '#316263' // Color de tu marca
    })
      .setLngLat([lng, lat])
      .addTo(map.current);
    
    // Si es draggable, emitir cambios
    if (draggable && onPositionChange) {
      marker.current.on('dragend', () => {
        const lngLat = marker.current!.getLngLat();
        onPositionChange(lngLat.lat, lngLat.lng);
      });
    }
    
    // A√±adir controles de zoom
    map.current.addControl(new mapboxgl.NavigationControl(), 'top-right');
    
    return () => {
      map.current?.remove();
    };
  }, []);
  
  return (
    <div>
      <div 
        ref={mapContainer} 
        className="w-full h-64 rounded-lg overflow-hidden border border-gray-200"
      />
      {draggable && (
        <p className="text-xs text-gray-500 mt-2 text-center">
          Arrastra el pin üìç para ajustar la ubicaci√≥n exacta
        </p>
      )}
    </div>
  );
}

üîß SCHEMA DE BASE DE DATOS ACTUALIZADO
sql-- Extender tabla properties
ALTER TABLE properties ADD COLUMN IF NOT EXISTS latitude DECIMAL(10, 8);
ALTER TABLE properties ADD COLUMN IF NOT EXISTS longitude DECIMAL(11, 8);
ALTER TABLE properties ADD COLUMN IF NOT EXISTS city VARCHAR(100);
ALTER TABLE properties ADD COLUMN IF NOT EXISTS country VARCHAR(100);
ALTER TABLE properties ADD COLUMN IF NOT EXISTS country_code VARCHAR(5);
ALTER TABLE properties ADD COLUMN IF NOT EXISTS postal_code VARCHAR(20);
ALTER TABLE properties ADD COLUMN IF NOT EXISTS neighborhood VARCHAR(100);
ALTER TABLE properties ADD COLUMN IF NOT EXISTS timezone VARCHAR(50);

-- Metadatos de geocoding
ALTER TABLE properties ADD COLUMN IF NOT EXISTS geocoding_confidence DECIMAL(3, 2);
ALTER TABLE properties ADD COLUMN IF NOT EXISTS geocoding_source VARCHAR(20);
ALTER TABLE properties ADD COLUMN IF NOT EXISTS geocoding_accuracy VARCHAR(20);
ALTER TABLE properties ADD COLUMN IF NOT EXISTS geocoding_validated_at TIMESTAMP;

-- √çndice para b√∫squedas geogr√°ficas
CREATE INDEX IF NOT EXISTS idx_properties_location ON properties(latitude, longitude);

üöÄ USO EN GENERACI√ìN DE CONTENIDO CON IA
Ahora la IA tiene datos precisos:
typescript// Al generar rutas y transporte

const propertyData = await supabase
  .from('properties')
  .select('*')
  .eq('id', propertyId)
  .single();

const prompt = `Genera instrucciones de transporte para llegar a esta propiedad:

UBICACI√ìN EXACTA:
- Direcci√≥n: ${propertyData.address}
- Coordenadas: ${propertyData.latitude}, ${propertyData.longitude}
- Ciudad: ${propertyData.city}
- Vecindario: ${propertyData.neighborhood}
- Pa√≠s: ${propertyData.country}

DESDE EL AEROPUERTO:
[Con las coordenadas exactas, genera rutas precisas de metro, taxi, bus]

METRO M√ÅS CERCANO:
[Con las coordenadas, busca la estaci√≥n real m√°s pr√≥xima]

PARKING P√öBLICO:
[Con las coordenadas, encuentra parkings cercanos reales]`;

// La IA ahora puede ser mucho m√°s precisa

üìä RESUMEN DE LA SOLUCI√ìN
AspectoSoluci√≥nFricci√≥n UsuarioInput del propietarioSolo direcci√≥n completa‚úÖ M√≠nimaGeocodingAutom√°tico multi-proveedor‚úÖ CeroValidaci√≥nIA + reglas‚úÖ Autom√°ticaConfirmaci√≥nMapa interactivo‚úÖ Visual, f√°cilPrecisi√≥nLat/Lng + contexto‚úÖ AltaCoste$0 con Mapbox/Nominatim‚úÖ Gratis

üí∞ COSTES
Opci√≥n 1: Mapbox (Recomendado para MVP)

100,000 geocoding requests/mes: GRATIS
Mapas ilimitados: GRATIS
Despu√©s: $0.50/1000 requests

Opci√≥n 2: Google Maps

$5 por 1000 geocoding requests
$7 por 1000 timezone requests
Para 100 propiedades: ~$1.20 one-time

Opci√≥n 3: Nominatim (OSM)

100% gratis
Limitado a 1 request/segundo
Menos preciso

Recomendaci√≥n: Empieza con Mapbox (gratis), cambia a Google solo si necesitas m√°s precisi√≥n.

‚úÖ IMPLEMENTACI√ìN PASO A PASO
typescript// 1. Instalar dependencias
npm install mapbox-gl @mapbox/mapbox-sdk

// 2. Variables de entorno (.env.local)
MAPBOX_API_KEY=pk.xxxxx
NEXT_PUBLIC_MAPBOX_TOKEN=pk.xxxxx  # Para el cliente
GOOGLE_MAPS_API_KEY=AIzaxxxxx  # Opcional, fallback

// 3. Crear archivos
lib/geocoding.ts          # Sistema de geocoding
lib/geocoding-validation.ts  # Validaci√≥n
components/MapPreview.tsx    # Mapa interactivo
components/LocationConfirmation.tsx  # UI confirmaci√≥n

// 4. Integrar en flujo de onboarding
app/dashboard/properties/create/page.tsx
Con esto, el propietario solo escribe la direcci√≥n y todo lo dem√°s es autom√°tico. Cero fricci√≥n, m√°xima precisi√≥n.
¬øQuieres que te prepare el c√≥digo completo listo para copiar y pegar?