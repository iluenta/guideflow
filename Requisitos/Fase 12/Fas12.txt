Plan Completo: Sistema Robusto de Generaci√≥n de Manuales
üéØ Objetivo
Crear un sistema que genere manuales detallados incluso sin PDF oficial, interpretando visualmente el panel de control y combinando m√∫ltiples fuentes de informaci√≥n.

üìã Arquitectura de 4 Niveles (Fallback Strategy)
Nivel 1: PDF Oficial Exacto (Ideal)
    ‚Üì Si falla
Nivel 2: Documentaci√≥n Web Fragmentada (Scraping)
    ‚Üì Si falla
Nivel 3: An√°lisis Visual Profundo + IA Generativa
    ‚Üì Siempre
Nivel 4: Validaci√≥n Cruzada y Enriquecimiento

üîß Implementaci√≥n Detallada
NIVEL 1: B√∫squeda Inteligente de PDF
typescript/**
 * B√∫squeda multi-estrategia del manual oficial
 */
async function findOfficialManual(brand: string, model: string, appliance_type: string): Promise<{
    pdfUrl?: string,
    webDocs: string[],
    confidence: 'high' | 'medium' | 'low'
}> {
    const strategies = [
        // Estrategia 1: Modelo exacto + PDF
        `"${brand}" "${model}" manual instrucciones filetype:pdf`,
        
        // Estrategia 2: E-Nr (com√∫n en Balay/Bosch/Siemens)
        `"${model}" "E-Nr" manual usuario filetype:pdf`,
        
        // Estrategia 3: Sitio oficial del fabricante
        `site:${getOfficialDomain(brand)} "${model}" manual`,
        
        // Estrategia 4: Modelo sin guiones/espacios (ej: 3HB4331X0 ‚Üí 3HB4331X0/54)
        `"${normalizeModel(model)}" manual pdf`,
        
        // Estrategia 5: Tipo de aparato gen√©rico (fallback)
        `"${brand}" ${appliance_type} manual instrucciones pdf`,
        
        // Estrategia 6: Portales de manuales
        `site:manualslib.com OR site:manualscat.com "${brand}" "${model}"`
    ]

    let pdfUrl: string | undefined
    let webDocs: string[] = []
    let bestConfidence: 'high' | 'medium' | 'low' = 'low'

    for (const [index, query] of strategies.entries()) {
        console.log(`[MANUAL SEARCH] Strategy ${index + 1}: ${query}`)
        
        try {
            const results = await searchBrave(query, { 
                count: 10,
                freshness: 'py' // √öltimo a√±o para evitar modelos discontinuados
            })
            
            if (!results.web?.results) continue

            // Buscar PDFs directos
            const pdfs = results.web.results
                .filter(r => r.url.toLowerCase().endsWith('.pdf'))
                .map(r => r.url)

            if (pdfs.length > 0) {
                pdfUrl = pdfs[0]
                bestConfidence = index < 2 ? 'high' : 'medium'
                console.log(`[MANUAL SEARCH] ‚úÖ Found PDF: ${pdfUrl}`)
                break
            }

            // Recolectar URLs de documentaci√≥n (para scraping posterior)
            const relevantDocs = results.web.results
                .filter(r => 
                    r.url.includes(brand.toLowerCase()) ||
                    r.url.includes('manual') ||
                    r.description?.toLowerCase().includes(model.toLowerCase())
                )
                .slice(0, 3)
                .map(r => r.url)

            webDocs.push(...relevantDocs)

        } catch (error) {
            console.error(`[MANUAL SEARCH] Strategy ${index + 1} failed:`, error)
        }

        // Delay para evitar rate limits
        await new Promise(res => setTimeout(res, 2000))
    }

    return { 
        pdfUrl, 
        webDocs: [...new Set(webDocs)], 
        confidence: pdfUrl ? bestConfidence : 'low' 
    }
}

function getOfficialDomain(brand: string): string {
    const domains: Record<string, string> = {
        'balay': 'balay.es',
        'bosch': 'bosch-home.es',
        'siemens': 'siemens-home.bsh-group.com',
        'teka': 'teka.com',
        'whirlpool': 'whirlpool.es',
        'lg': 'lg.com',
        'samsung': 'samsung.com'
    }
    return domains[brand.toLowerCase()] || `${brand.toLowerCase()}.com`
}

function normalizeModel(model: string): string {
    // 3HB4331X0/54 ‚Üí 3HB4331X0
    return model.replace(/[\/\-\s]/g, '').toUpperCase()
}

NIVEL 2: Scraping de Documentaci√≥n Fragmentada
typescript/**
 * Extrae contenido t√©cnico de p√°ginas web cuando no hay PDF
 */
async function scrapeManualContent(urls: string[]): Promise<string> {
    let aggregatedContent = ''

    for (const url of urls.slice(0, 3)) { // Limitar a 3 URLs
        try {
            console.log(`[WEB SCRAPE] Fetching: ${url}`)
            
            // Usar Jina Reader para obtener contenido limpio
            const response = await axios.get(`https://r.jina.ai/${encodeURIComponent(url)}`, {
                timeout: 20000,
                headers: { 'X-Return-Format': 'markdown' }
            })

            const content = response.data
            
            // Filtrar secciones relevantes (heur√≠stica)
            const relevantSections = extractRelevantSections(content)
            aggregatedContent += `\n\n## Fuente: ${url}\n${relevantSections}`

        } catch (error) {
            console.error(`[WEB SCRAPE] Failed for ${url}:`, error)
        }
    }

    return aggregatedContent
}

function extractRelevantSections(markdown: string): string {
    const keywords = [
        'funci√≥n', 's√≠mbolo', 'programa', 'temperatura', 
        'mando', 'panel', 'control', 'uso', 'instrucci√≥n',
        'modo', 'cocci√≥n', 'nivel', 'accesorio'
    ]

    const lines = markdown.split('\n')
    let relevantContent = ''
    let buffer: string[] = []
    let isRelevant = false

    for (const line of lines) {
        const lowerLine = line.toLowerCase()
        
        // Detectar inicio de secci√≥n relevante
        if (keywords.some(kw => lowerLine.includes(kw))) {
            isRelevant = true
        }

        // Detectar fin de secci√≥n (l√≠nea vac√≠a o nuevo header)
        if (isRelevant && (line.trim() === '' || line.startsWith('#'))) {
            if (buffer.length > 0) {
                relevantContent += buffer.join('\n') + '\n\n'
                buffer = []
            }
            isRelevant = line.startsWith('#') && keywords.some(kw => lowerLine.includes(kw))
        }

        if (isRelevant) {
            buffer.push(line)
        }
    }

    return relevantContent.substring(0, 10000) // Limitar tama√±o
}

NIVEL 3: An√°lisis Visual Profundo (Sin Etiqueta)
Este es el caso de la segunda imagen que subiste (panel sin etiqueta visible).
typescript/**
 * An√°lisis visual en 2 fases cuando no hay etiqueta
 */
async function analyzeControlPanelVisually(imageUrl: string): Promise<{
    brand?: string,
    estimatedModel?: string,
    controls: ControlElement[],
    layout: PanelLayout
}> {
    
    // FASE 1: Identificaci√≥n de Marca y Tipo
    const identificationPrompt = `Analiza esta imagen de un panel de control de electrodom√©stico.

TAREA 1: Identificar la marca
- Busca logos, nombres, tipograf√≠a caracter√≠stica
- Si ves "Balay", "Bosch", "Siemens", etc., ind√≠calo
- Considera el dise√±o: ¬øes BSH Group? ¬øElectrolux? ¬øLG?

TAREA 2: Tipo de aparato
- ¬øHorno? ¬øMicroondas? ¬øPlaca? ¬øLavavajillas?
- Razona por los s√≠mbolos visibles

TAREA 3: Caracter√≠sticas del Panel
- ¬øTiene pantalla digital? ¬øQu√© muestra?
- ¬øMandos giratorios? ¬øCu√°ntos?
- ¬øBotones t√°ctiles? ¬øEscamoteables?
- ¬øQu√© rango de temperatura muestra? (ej: 50-250¬∞C)

FORMATO JSON:
{
  "brand": "marca inferida o 'desconocida'",
  "confidence_brand": 0.0-1.0,
  "appliance_type": "HORNO/MICROONDAS/etc",
  "panel_type": "digital/anal√≥gico/mixto",
  "has_retractable_knobs": boolean,
  "temperature_range": "min-max",
  "display_shows": "descripci√≥n de lo que muestra la pantalla",
  "reasoning": "por qu√© crees que es esta marca/modelo"
}`

    const phase1 = await analyzeImageWithGemini(imageUrl, identificationPrompt, {
        responseMimeType: 'application/json',
        temperature: 0.3
    })

    // FASE 2: Mapeo Detallado de Controles
    const controlMappingPrompt = `Ahora analiza CADA elemento de control visible en esta imagen.

Para el MANDO IZQUIERDO:
- Lista TODOS los s√≠mbolos/iconos alrededor (en sentido horario desde las 12)
- Describe cada s√≠mbolo (ej: "ventilador con c√≠rculo", "dos l√≠neas horizontales")

Para el MANDO DERECHO:
- ¬øEs de temperatura? ¬øQu√© n√∫meros/marcas tiene?
- ¬øTiene posiciones espec√≠ficas?

Para la PANTALLA DIGITAL:
- ¬øQu√© est√° mostrando actualmente?
- ¬øQu√© botones hay junto a ella? (ej: campana, -, +, reloj)

Para OTROS CONTROLES:
- ¬øHay botones adicionales?
- ¬øHay selectores de programa?

FORMATO JSON:
{
  "left_knob": {
    "type": "funci√≥n/modo",
    "symbols": [
      { "position": "12h", "description": "...", "likely_meaning": "..." },
      { "position": "1h", "description": "...", "likely_meaning": "..." }
      // ... todos los s√≠mbolos
    ]
  },
  "right_knob": {
    "type": "temperatura/nivel",
    "min_value": "...",
    "max_value": "...",
    "increments": "..."
  },
  "digital_display": {
    "current_display": "11:49",
    "adjacent_buttons": [
      { "icon": "campana", "likely_function": "temporizador" },
      { "icon": "-", "likely_function": "decrementar" }
      // ...
    ]
  },
  "other_controls": []
}`

    const phase2 = await analyzeImageWithGemini(imageUrl, controlMappingPrompt, {
        responseMimeType: 'application/json',
        temperature: 0.2
    })

    return {
        brand: phase1?.data?.brand,
        estimatedModel: phase1?.data?.confidence_brand > 0.7 ? 'Modelo estimado por IA' : undefined,
        controls: phase2?.data,
        layout: phase1?.data
    }
}

interface ControlElement {
    type: string
    position?: string
    description: string
    likely_meaning: string
}

interface PanelLayout {
    panel_type: string
    has_retractable_knobs: boolean
    temperature_range: string
}

NIVEL 4: Generaci√≥n H√≠brida del Manual
typescript/**
 * Genera el manual combinando TODAS las fuentes disponibles
 */
async function generateHybridManual(context: {
    imageUrl: string,
    pdfContent?: string,
    webContent?: string,
    visualAnalysis: any,
    confidence: 'high' | 'medium' | 'low'
}): Promise<string> {
    
    const { pdfContent, webContent, visualAnalysis, confidence } = context

    let basePrompt = `ERES UN EXPERTO EN ELECTRODOM√âSTICOS CREANDO UNA GU√çA DE USO PARA HU√âSPEDES.

**CONTEXTO DISPONIBLE:**`

    // Estrategia seg√∫n nivel de confianza
    if (confidence === 'high' && pdfContent) {
        basePrompt += `
üìÑ **MANUAL OFICIAL (FUENTE PRIMARIA):**
${pdfContent.substring(0, 25000)}

üéØ OBJETIVO: Traducir el manual oficial a una gu√≠a amigable para hu√©spedes.`

    } else if (confidence === 'medium' && webContent) {
        basePrompt += `
üåê **DOCUMENTACI√ìN WEB FRAGMENTADA:**
${webContent.substring(0, 15000)}

üëÅÔ∏è **AN√ÅLISIS VISUAL DEL PANEL:**
${JSON.stringify(visualAnalysis, null, 2)}

üéØ OBJETIVO: Combinar informaci√≥n web + an√°lisis visual para crear una gu√≠a coherente.`

    } else {
        // Caso m√°s dif√≠cil: solo an√°lisis visual
        basePrompt += `
üëÅÔ∏è **AN√ÅLISIS VISUAL PROFUNDO DEL PANEL:**
${JSON.stringify(visualAnalysis, null, 2)}

‚ö†Ô∏è **SITUACI√ìN:** No se encontr√≥ manual oficial. Debes inferir el funcionamiento bas√°ndote en:
1. Los s√≠mbolos est√°ndar de la industria
2. El dise√±o del panel (marca: ${visualAnalysis.brand || 'desconocida'})
3. Patrones comunes en hornos ${visualAnalysis.appliance_type}

üéØ OBJETIVO: Crear una gu√≠a √∫til aunque no sea 100% espec√≠fica del modelo.`
    }

    basePrompt += `

üìã **ESTRUCTURA OBLIGATORIA DEL MANUAL:**

# Gu√≠a de Uso: ${visualAnalysis.brand || 'Horno'} ${visualAnalysis.estimatedModel || ''}

## 1. PANEL DE CONTROL Y S√çMBOLOS

### Mando de Funciones (Izquierda)
${generateSymbolTable(visualAnalysis.controls?.left_knob)}

### Mando de Temperatura (Derecha)
- **Rango:** ${visualAnalysis.controls?.right_knob?.min_value} - ${visualAnalysis.controls?.right_knob?.max_value}
- **Uso:** [Explicar c√≥mo ajustar temperatura]

### Pantalla y Botones
${generateDisplayGuide(visualAnalysis.controls?.digital_display)}

## 2. MODOS DE COCCI√ìN DISPONIBLES
[Para cada s√≠mbolo del mando de funciones, explica:]
- **Nombre del modo**
- **Cu√°ndo usarlo** (ej: "Ideal para pizzas y tartas")
- **Temperatura recomendada**
- **Nivel de bandeja** (si se conoce)

## 3. INSTRUCCIONES PASO A PASO

### Primera vez que usas el horno:
1. [Pasos iniciales]

### Para cocinar:
1. **Seleccionar modo:** Gira el mando izquierdo hasta el s√≠mbolo deseado
2. **Ajustar temperatura:** Gira el mando derecho a los grados necesarios
3. **Programar tiempo (opcional):** [Explicar botones de reloj]
4. **Precalentar:** [¬øEs necesario? ¬øC√≥mo saberlo?]

## 4. FUNCIONES ESPECIALES

### Temporizador/Reloj
${visualAnalysis.controls?.digital_display?.adjacent_buttons ? 
  'Usa los botones junto a la pantalla para programar tiempo de cocci√≥n' : 
  'Este modelo puede no tener temporizador programable'}

### Mandos Escamoteables (si aplica)
${visualAnalysis.layout?.has_retractable_knobs ? 
  '‚ö†Ô∏è Los mandos se presionan para extraerlos y se presionan de nuevo para guardarlos.' : 
  'Los mandos son fijos.'}

## 5. CONSEJOS Y PRECAUCIONES
- **Limpieza:** [Consejos generales seguros]
- **Seguridad:** No tocar el cristal durante el funcionamiento
- **Mantenimiento:** [B√°sico]

## 6. SOLUCI√ìN DE PROBLEMAS
- **No enciende:** Verificar que ambos mandos est√©n en posici√≥n distinta de 0
- **No calienta:** [Posibles causas]

---

üö´ **PROHIBICIONES:**
1. NO digas "la imagen muestra" o "en la foto"
2. NO uses condicionales ("podr√≠a", "quiz√°s") si tienes datos del manual oficial
3. SI solo tienes an√°lisis visual, S√ç puedes usar: "T√≠picamente este s√≠mbolo significa..."
4. NO inventes n√∫meros de modelo si no los conoces

‚úÖ **SI NO TIENES CERTEZA:** Usa frases como:
- "Este s√≠mbolo generalmente se usa para..."
- "En hornos de esta marca, este modo suele ser..."
- "Consulta el manual f√≠sico para confirmar..."

FORMATO: Markdown limpio y estructurado.
LONGITUD: M√≠nimo 1200 palabras.

RESPONDE √öNICAMENTE CON EL MANUAL.`

    const manual = await geminiREST('gemini-2.0-flash-exp', basePrompt, {
        responseMimeType: 'text/plain',
        temperature: confidence === 'high' ? 0.2 : 0.4, // M√°s creativo si no hay manual
        maxOutputTokens: 8000
    })

    return manual?.data || ''
}

function generateSymbolTable(leftKnob: any): string {
    if (!leftKnob?.symbols) return 'No se pudieron identificar los s√≠mbolos.'
    
    let table = `| Posici√≥n | S√≠mbolo Visual | Funci√≥n Estimada |\n|----------|---------------|------------------|\n`
    
    for (const symbol of leftKnob.symbols) {
        table += `| ${symbol.position} | ${symbol.description} | ${symbol.likely_meaning} |\n`
    }
    
    return table
}

function generateDisplayGuide(display: any): string {
    if (!display) return 'Panel sin pantalla digital.'
    
    let guide = `**Pantalla actual:** ${display.current_display}\n\n`
    guide += `**Botones disponibles:**\n`
    
    for (const btn of display.adjacent_buttons || []) {
        guide += `- **${btn.icon}:** ${btn.likely_function}\n`
    }
    
    return guide
}

Integraci√≥n Final en processBatchScans
typescriptexport async function processBatchScans(propertyId: string, imageUrls: string[], replaceExisting: boolean = false) {
    // ... c√≥digo existente ...

    for (const [index, url] of imageUrls.entries()) {
        try {
            // PASO 1: An√°lisis Visual Inicial (siempre)
            console.log(`[PROCESS] [${index + 1}] Step 1: Visual analysis...`)
            const visualAnalysis = await analyzeControlPanelVisually(url)

            // PASO 2: B√∫squeda Inteligente de Manual
            console.log(`[PROCESS] [${index + 1}] Step 2: Searching for manual...`)
            const manualSearch = await findOfficialManual(
                visualAnalysis.brand || 'generic',
                visualAnalysis.estimatedModel || '',
                visualAnalysis.layout?.appliance_type || 'horno'
            )

            // PASO 3: Extracci√≥n de Contenido
            let pdfContent = ''
            let webContent = ''

            if (manualSearch.pdfUrl) {
                console.log(`[PROCESS] [${index + 1}] Step 3a: Extracting PDF...`)
                pdfContent = await extractPDFManual(manualSearch.pdfUrl)
            }

            if (!pdfContent && manualSearch.webDocs.length > 0) {
                console.log(`[PROCESS] [${index + 1}] Step 3b: Scraping web docs...`)
                webContent = await scrapeManualContent(manualSearch.webDocs)
            }

            // PASO 4: Generaci√≥n H√≠brida
            console.log(`[PROCESS] [${index + 1}] Step 4: Generating hybrid manual (confidence: ${manualSearch.confidence})...`)
            const manualContent = await generateHybridManual({
                imageUrl: url,
                pdfContent,
                webContent,
                visualAnalysis,
                confidence: manualSearch.confidence
            })

            // PASO 5: Guardar (igual que antes)
            // ... resto del c√≥digo ...

        } catch (err) {
            console.error(`[PROCESS] Error:`, err)
        }
    }
}

üé® Mejoras Adicionales
1. Cach√© de Manuales
typescript// Evitar redownload de PDFs ya procesados
const manualCache = new Map<string, string>()

async function extractPDFManual(pdfUrl: string): Promise<string> {
    if (manualCache.has(pdfUrl)) {
        console.log('[PDF] Using cached version')
        return manualCache.get(pdfUrl)!
    }
    
    // ... extracci√≥n normal ...
    manualCache.set(pdfUrl, content)
    return content
}
2. Validaci√≥n Post-Generaci√≥n
typescriptasync function validateManual(manual: string, imageUrl: string): Promise<{
    isComplete: boolean,
    missingElements: string[]
}> {
    const validationPrompt = `Compara esta imagen del panel con el manual generado:

MANUAL:
${manual.substring(0, 5000)}

RESPONDE JSON:
{
  "symbols_in_image": ["lista de s√≠mbolos visibles"],
  "symbols_in_manual": ["lista de s√≠mbolos mencionados"],
  "missing": ["s√≠mbolos no explicados"],
  "isComplete": boolean
}`

    const result = await analyzeImageWithGemini(imageUrl, validationPrompt, {
        responseMimeType: 'application/json'
    })

    return result?.data || { isComplete: false, missingElements: [] }
}
3. Feedback Loop
typescript// Si la validaci√≥n detecta elementos faltantes, regenerar
if (!validation.isComplete && validation.missingElements.length > 0) {
    console.log(`[VALIDATION] Regenerating with missing elements: ${validation.missingElements}`)
    
    constË°•ÂÖÖPrompt = `El manual anterior omiti√≥ estos elementos visibles:
${validation.missingElements.join(', ')}

Genera SOLO las secciones faltantes en formato markdown.`
    
    const supplement = await analyzeImageWithGemini(url, Ë°•ÂÖÖPrompt)
    manualContent += `\n\n## Informaci√≥n Adicional\n${supplement.data}`
}

üìä Matriz de Confianza
EscenarioPDFWeb DocsVisualConfianzaCalidad EsperadaEtiqueta clara + PDF encontrado‚úÖ-‚úÖHigh95% precisoEtiqueta + Web docs‚ùå‚úÖ‚úÖMedium80% precisoSolo panel visible‚ùå‚ùå‚úÖLow60-70% √∫tilAparato antiguo + Web‚ùå‚úÖ (gen√©rico)‚úÖMedium-Low70% √∫til

üöÄ Resultado Final
Con este sistema completo:
‚úÖ Con etiqueta + PDF: Manual exacto con todos los s√≠mbolos del modelo
‚úÖ Con etiqueta sin PDF: Manual basado en docs web + inferencia visual
‚úÖ Sin etiqueta (como tu 2¬™ imagen): Manual interpretativo √∫til
‚úÖ Aparatos antiguos: B√∫squeda ampliada + contenido gen√©rico de calidad
El sistema siempre genera algo √∫til, escalando la precisi√≥n seg√∫n los datos disponibles.